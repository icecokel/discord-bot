# 🚀 내 코드가 디스코드 봇이 되는 과정 (The Deployment Pipeline)

개발자가 작성한 코드가 어떻게 서버로 넘어가서 실제로 움직이는지, **"코드의 이동 경로"**를 중심으로 설명합니다.

---

## 1. 코드 작성 및 전송 (Local → Remote)

개발자가 로컬(내 컴퓨터)에서 코드를 작성하고 저장한다고 바로 서버에 반영되지 않습니다. **Git**을 통해 코드를 배달해야 합니다.

1.  **Commit**: 변경 사항(코드)을 포장합니다.
2.  **Push**: 포장된 코드를 **GitHub(원격 저장소)**로 보냅니다.
    - 이 시점까지는 실제 봇 서버에 아무런 변화가 없습니다. 단순히 코드 저장소만 업데이트된 상태입니다.

## 2. 서버 업데이트 (Remote → Server)

이제 봇이 살고 있는 **서버(24시간 켜진 컴퓨터)** 가 최신 코드를 받아야 합니다.

1.  **Pull**: 서버가 GitHub에서 최신 코드를 당겨옵니다 (`git pull`).
    - 이제 서버의 폴더 내용도 내 컴퓨터와 똑같아졌습니다.
2.  **Install**: 새로운 기능에 필요한 부품(라이브러리)이 추가되었다면 설치합니다 (`npm install`).

## 3. 프로세스 재시작 (Restart)

코드가 바뀌었어도, 이미 실행 중인 봇 프로그램(메모리에 올라간 프로세스)은 *옛날 코드*를 기억하고 있습니다.

1.  **Kill**: 실행 중이던 옛날 봇 프로세스를 종료합니다.
2.  **Start**: 새로운 코드로 다시 `node index.js`를 실행합니다.
    - 보통 이 과정은 `pm2 restart` 같은 명령어로 1초 안에 순식간에 일어납니다.

## 4. 디스코드 연결 (Login & Gateway)

새로 태어난 봇 프로세스가 다시 일을 시작합니다.

1.  **Login**: `.env`에 있는 **토큰**을 가지고 디스코드 본사(Gateway)에 로그인 요청을 보냅니다.
2.  **Connection**: 로그인이 성공하면 디스코드 서버와 **WebSocket**이라는 전용 직통 전화가 연결됩니다.
3.  **Standby**: 이제 봇은 디스코드 서버로부터 오는 "누가 메시지 썼음" 이라는 신호를 기다리는 상태가 됩니다.

## 요약

> **내 컴퓨터(작성)** ➡️ `git push` ➡️ **GitHub(저장)** ➡️ `git pull` ➡️ **서버(동기화)** ➡️ **재시작(적용)** ➡️ **디스코드 로그인(완료)**

이 과정을 거쳐야 비로소 친구들이 디스코드에서 바뀐 기능을 사용할 수 있게 됩니다.

---

## ❓ 자주 묻는 질문 (FAQ)

### Q1. 그럼 제 컴퓨터(로컬)가 계속 켜져 있어야 하나요?

- **개발 중(npm run dev)**: 네, 맞습니다. 이때는 **"내 컴퓨터 = 서버"**입니다. 컴퓨터를 끄면 봇도 꺼집니다.
- **배포 후(Server)**: 아니요. 코드를 **클라우드 서버(남의 컴퓨터)**로 보냈기 때문에, 이제는 그 클라우드 서버가 봇을 돌립니다. 내 컴퓨터를 꺼도 봇은 그쪽에서 계속 살아있습니다.

### Q2. "게이트웨이가 뚫렸다"는 게 무슨 뜻인가요? (포트 개방?)

- 디스코드 봇은 내 컴퓨터(또는 서버)의 대문을 열어놓고 손님을 기다리는 방식(**Inbound**)이 **아닙니다.**
- 오히려 봇이 먼저 디스코드 본사에 전화를 걸어 연결을 유지하는 방식(**Outbound**)입니다.
- 그래서 방화벽 구멍을 뚫거나 포트 포워딩을 할 필요가 없습니다. 그냥 인터넷만 되면 **어디서든** 실행할 수 있습니다.

### Q3. 그럼 제 봇을 위해 어딘가에 컴퓨터가 24시간 켜져 있어야 한다는 건가요?

- **네, 정답입니다!** 💯
- 우리가 흔히 말하는 **"서버"**는 특별한 기계가 아니라, **"24시간 끄지 않고 전기세와 인터넷 비용을 내면서 켜두는 컴퓨터"**일 뿐입니다.
- AWS, Google Cloud 같은 클라우드 서비스는 이런 컴퓨터를 수만 대 켜놓고, 우리에게 그중 일부를 빌려주는 것입니다.
